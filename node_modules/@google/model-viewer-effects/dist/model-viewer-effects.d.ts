import { BlendFunction, EffectComposer as EffectComposer$1, Pass, RenderPass, NormalPass, Selection, EffectPass, Effect, BlendMode as BlendMode$1, BloomEffect, ToneMappingMode as ToneMappingMode$1, ChromaticAberrationEffect, GlitchEffect, OutlineEffect, SMAAPreset, SSAOEffect, SelectiveBloomEffect } from 'postprocessing';
import * as lit from 'lit';
import { ReactiveElement, LitElement } from 'lit';
import * as three from 'three';
import { Camera, ToneMapping, WebGLRenderer, Object3D, ColorRepresentation } from 'three';
import * as _google_model_viewer_lib_model_viewer_base_js from '@google/model-viewer/lib/model-viewer-base.js';
import * as _google_model_viewer_lib_features_animation_js from '@google/model-viewer/lib/features/animation.js';
import * as _google_model_viewer_lib_features_loading_js from '@google/model-viewer/lib/features/loading.js';
import * as _google_model_viewer_lib_features_ar_js from '@google/model-viewer/lib/features/ar.js';
import * as _google_model_viewer_lib_features_controls_js from '@google/model-viewer/lib/features/controls.js';
import * as _google_model_viewer_lib_features_environment_js from '@google/model-viewer/lib/features/environment.js';
import * as _google_model_viewer_lib_features_staging_js from '@google/model-viewer/lib/features/staging.js';
import * as _google_model_viewer_lib_features_scene_graph_js from '@google/model-viewer/lib/features/scene-graph.js';
import * as _google_model_viewer_lib_features_annotation_js from '@google/model-viewer/lib/features/annotation.js';
import { ModelViewerElement } from '@google/model-viewer';
import { ModelScene } from '@google/model-viewer/lib/three-components/ModelScene.js';

type Constructor<T = object, U = object> = {
    new (...args: any[]): T;
    prototype: T;
} & U;

declare const $setDefaultProperties: unique symbol;
type BlendMode = keyof typeof BlendFunction;
interface IBlendModeMixin {
    opacity: number;
    blendMode: BlendMode;
    [$setDefaultProperties](): void;
}

declare const $scene: unique symbol;
declare const $composer: unique symbol;
declare const $modelViewerElement: unique symbol;
declare const $effectComposer: unique symbol;
declare const $renderPass: unique symbol;
declare const $normalPass: unique symbol;
declare const $effectPasses: unique symbol;
declare const $requires: unique symbol;
declare const $effects: unique symbol;
declare const $selection: unique symbol;
declare const $onSceneLoad: unique symbol;
declare const $resetEffectPasses: unique symbol;
declare const $userEffectCount: unique symbol;
declare const $tonemapping: unique symbol;
declare const $updateProperties$1: unique symbol;
/**
 * Light wrapper around {@link EffectComposer} for storing the `scene` and
 * `camera at a top level, and setting them for every {@link Pass} added.
 */
declare class EffectComposer extends EffectComposer$1 {
    camera?: Camera;
    scene?: ModelScene;
    dirtyRender?: boolean;
    [$tonemapping]: ToneMapping;
    constructor(renderer?: WebGLRenderer, options?: {
        depthBuffer?: boolean;
        stencilBuffer?: boolean;
        alpha?: boolean;
        multisampling?: number;
        frameBufferType?: number;
    });
    private preRender;
    private postRender;
    render(deltaTime?: number | undefined): void;
    /**
     * Adds a pass, optionally at a specific index.
     * Additionally sets `scene` and `camera`.
     * @param pass A new pass.
     * @param index An index at which the pass should be inserted.
     */
    addPass(pass: Pass, index?: number): void;
    setMainCamera(camera: Camera): void;
    setMainScene(scene: ModelScene): void;
    /**
     * Effect Materials that use the camera need to be manually updated whenever
     * the camera settings update.
     */
    refresh(): void;
    beforeRender(_time: DOMHighResTimeStamp, _delta: DOMHighResTimeStamp): void;
}
type MVPass = Pass & IntegrationOptions;
declare const RENDER_MODES: readonly ["performance", "quality"];
type RenderMode = typeof RENDER_MODES[number];
declare class MVEffectComposer extends ReactiveElement {
    static get is(): string;
    /**
     * `quality` | `performance`. Changing this after the element was constructed
     * has no effect.
     *
     * Using `quality` improves banding on certain effects, at a memory cost. Use
     * in HDR scenarios.
     *
     * `performance` should be sufficient for most use-cases.
     * @default 'performance'
     */
    renderMode: RenderMode;
    /**
     * Anti-Aliasing using the MSAA algorithm. Doesn't work well with depth-based
     * effects.
     *
     * Recommended to use with a factor of 2.
     * @default 0
     */
    msaa: number;
    protected [$composer]?: EffectComposer;
    protected [$modelViewerElement]?: ModelViewerElement;
    protected [$renderPass]: RenderPass;
    protected [$normalPass]: NormalPass;
    protected [$selection]: Selection;
    protected [$userEffectCount]: number;
    get [$effectComposer](): EffectComposer;
    /**
     * Array of custom {@link MVPass}'s added with {@link addPass}.
     */
    get userPasses(): MVPass[];
    get modelViewerElement(): _google_model_viewer_lib_features_annotation_js.AnnotationInterface & _google_model_viewer_lib_features_scene_graph_js.SceneGraphInterface & _google_model_viewer_lib_features_staging_js.StagingInterface & _google_model_viewer_lib_features_environment_js.EnvironmentInterface & _google_model_viewer_lib_features_controls_js.ControlsInterface & _google_model_viewer_lib_features_ar_js.ARInterface & _google_model_viewer_lib_features_loading_js.LoadingInterface & _google_model_viewer_lib_features_animation_js.AnimationInterface & _google_model_viewer_lib_model_viewer_base_js.default;
    /**
     * The Texture buffer of the inbuilt {@link NormalPass}.
     */
    get normalBuffer(): three.Texture;
    /**
     * A selection of all {@link Mesh}'s in the ModelScene.
     */
    get selection(): Selection;
    /**
     * Creates a new MVEffectComposer element.
     *
     * @warning The EffectComposer instance is created only on connection with the
     * DOM, so that the renderMode is properly taken into account. Do not interact
     * with this class if it is not mounted to the DOM.
     */
    constructor();
    connectedCallback(): void;
    disconnectedCallback(): void;
    updated(changedProperties: Map<string | number | symbol, any>): void;
    /**
     * Adds a custom Pass that extends the {@link Pass} class.
     * All passes added through this method will be prepended before all other
     * web-component effects.
     *
     * This method automatically sets the `mainScene` and `mainCamera` of the
     * pass.
     * @param {Pass} pass Custom Pass to add. The camera and scene are set
     *     automatically.
     * @param {boolean} requireNormals Whether any effect in this pass uses
     *     the {@link normalBuffer}
     * @param {boolean} requireDirtyRender Enable this if the effect requires a
     *     render frame every frame. Significant performance impact from enabling
     *     this.
     */
    addPass(pass: Pass, requireNormals?: boolean, requireDirtyRender?: boolean): void;
    /**
     * Removes and optionally disposes of a previously added Pass.
     * @param pass Custom Pass to remove
     * @param {Boolean} dispose Disposes of the Pass properties and effects.
     *     Default is `true`.
     */
    removePass(pass: Pass, dispose?: boolean): void;
    /**
     * Updates all existing EffectPasses, adding any new `<model-viewer-effects>`
     * Effects in the order they were added, after any custom Passes added
     * with {@link addPass}.
     *
     * Runs automatically whenever a new Effect is added.
     */
    updateEffects(): void;
    /**
     * Request a render-frame manually.
     */
    queueRender(): void;
    get [$scene](): ModelScene | undefined;
    /**
     * Gets child effects
     */
    get [$effects](): IMVEffect[];
    /**
     * Gets effectPasses of child effects
     */
    get [$effectPasses](): EffectPass[];
    [$onSceneLoad]: () => void;
    [$updateProperties$1](): void;
    [$requires](property: 'requireNormals' | 'requireSeparatePass' | 'requireDirtyRender'): boolean;
    [$resetEffectPasses](): void;
}

declare const $updateProperties: unique symbol;
declare const $effectOptions: unique symbol;
interface IMVBlendMode extends BlendMode$1 {
    defaultBlendFunction?: BlendFunction;
}
interface IntegrationOptions {
    /**
     * Enable this if effect uses the built-in {@link NormalPass}
     */
    requireNormals?: boolean;
    /**
     * Enable this if the effect requires a render frame every frame.
     * @warning Significant performance impact from enabling this
     */
    requireDirtyRender?: boolean;
}
interface IMVEffect extends Effect, IntegrationOptions {
    readonly blendMode: IMVBlendMode;
    /**
     * Enable this if the effect doesn't play well when used with other effects.
     */
    requireSeparatePass?: boolean;
    disabled?: boolean;
}
interface IEffectBaseMixin {
    effects: IMVEffect[];
    effectComposer: MVEffectComposer;
}
declare const MVEffectBase: {
    new (...args: any[]): IBlendModeMixin;
    prototype: IBlendModeMixin;
} & object & {
    new (...args: any[]): IEffectBaseMixin;
    prototype: IEffectBaseMixin;
} & typeof LitElement;
type MVEffectBase = InstanceType<typeof MVEffectBase>;

declare class MVBloomEffect extends MVEffectBase {
    static get is(): string;
    /**
     * The strength of the bloom effect.
     */
    strength: number;
    /**
     * Value in the range of (0, 1). Pixels with a brightness above this will bloom.
     */
    threshold: number;
    /**
     * Value in the range of (0, 1).
     */
    radius: number;
    /**
     * Value in the range of (0, 1).
     */
    smoothing: number;
    constructor();
    connectedCallback(): void;
    updated(changedProperties: Map<string | number | symbol, any>): void;
    [$updateProperties](): void;
    get [$effectOptions](): ConstructorParameters<typeof BloomEffect>[0];
}

type ToneMappingMode = keyof typeof ToneMappingMode$1;
declare class MVColorGradeEffect extends MVEffectBase {
    static get is(): string;
    /**
     * `reinhard | reinhard2 | reinhard_adaptive | optimized_cineon | aces_filmic
     * | linear`
     * @default 'aces_filmic'
     */
    tonemapping: ToneMappingMode;
    /**
     * Value in the range of (-1, 1).
     */
    brightness: number;
    /**
     * Value in the range of (-1, 1).
     */
    contrast: number;
    /**
     * Value in the range of (-1, 1).
     */
    saturation: number;
    /**
     * Value in the range of (0, 2 * PI).
     *
     * This property is wrapping, meaning that if you set it above the max it
     * resets to the minimum and vice-versa.
     */
    hue: number;
    constructor();
    connectedCallback(): void;
    updated(changedProperties: Map<string | number | symbol, any>): void;
    [$updateProperties](): void;
}

declare const GLITCH_MODES: readonly ["sporadic", "constant"];
type GlitchMode = typeof GLITCH_MODES[number];
declare class MVGlitchEffect extends MVEffectBase {
    static get is(): string;
    /**
     * Value in the range of (0, 1).
     */
    strength: number;
    /**
     * `sporadic` | `constant`
     * @default 'sporadic'
     */
    mode: GlitchMode;
    constructor();
    connectedCallback(): void;
    updated(changedProperties: Map<string | number | symbol, any>): void;
    [$updateProperties](): void;
    [$effectOptions](chromaticAberrationEffect: ChromaticAberrationEffect): ConstructorParameters<typeof GlitchEffect>[0];
}

interface ISelectiveMixin {
    selection: Array<string | Object3D>;
}
declare const SelectiveMixin: <T extends Constructor<IEffectBaseMixin & ReactiveElement>>(EffectClass: T) => Constructor<ISelectiveMixin> & T;

declare const MVOutlineEffect_base: {
    new (...args: any[]): ISelectiveMixin;
    prototype: ISelectiveMixin;
} & object & {
    new (...args: any[]): IBlendModeMixin;
    prototype: IBlendModeMixin;
} & {
    new (...args: any[]): IEffectBaseMixin;
    prototype: IEffectBaseMixin;
} & typeof lit.LitElement;
declare class MVOutlineEffect extends MVOutlineEffect_base {
    static get is(): string;
    /**
     * String or RGB #-hexadecimal Color.
     * @default 'white'
     */
    color: ColorRepresentation;
    /**
     * A larger value denotes a thicker edge.
     * @default 1
     */
    strength: number;
    /**
     * Value in the range of (0, 6). Controls the edge blur strength.
     * @default 1
     */
    smoothing: number;
    constructor();
    connectedCallback(): void;
    updated(changedProperties: Map<string | number | symbol, any>): void;
    [$updateProperties](): void;
    get [$effectOptions](): ConstructorParameters<typeof OutlineEffect>[2];
}

declare class MVPixelateEffect extends MVEffectBase {
    static get is(): string;
    /**
     * The pixel granularity. Higher value = lower resolution.
     * @default 10
     */
    granularity: number;
    constructor();
    connectedCallback(): void;
    updated(changedProperties: Map<string | number | symbol, any>): void;
    [$updateProperties](): void;
}

type SMAAQuality = keyof typeof SMAAPreset;
declare class MVSMAAEffect extends MVEffectBase {
    static get is(): string;
    /**
     * `low | medium | high | ultra`
     * @default 'medium'
     */
    quality: SMAAQuality;
    constructor();
    connectedCallback(): void;
    updated(changedProperties: Map<string | number | symbol, any>): void;
    [$updateProperties](): void;
}

declare class MVSSAOEffect extends MVEffectBase {
    static get is(): string;
    /**
     * The strength of the shadow occlusions. Higher value means darker shadows.
     */
    strength: number;
    constructor();
    connectedCallback(): void;
    update(changedProperties: Map<string | number | symbol, any>): void;
    [$updateProperties](): void;
    [$setDefaultProperties](): void;
    get [$effectOptions](): ConstructorParameters<typeof SSAOEffect>[2];
}

declare const MVSelectiveBloomEffect_base: {
    new (...args: any[]): ISelectiveMixin;
    prototype: ISelectiveMixin;
} & object & {
    new (...args: any[]): IBlendModeMixin;
    prototype: IBlendModeMixin;
} & {
    new (...args: any[]): IEffectBaseMixin;
    prototype: IEffectBaseMixin;
} & typeof lit.LitElement;
declare class MVSelectiveBloomEffect extends MVSelectiveBloomEffect_base {
    static get is(): string;
    /**
     * The strength of the bloom effect.
     */
    strength: number;
    /**
     * Value in the range of (0, 1). Pixels with a brightness above this will bloom.
     */
    threshold: number;
    /**
     * Value in the range of (0, 1).
     */
    smoothing: number;
    /**
     * Value in the range of (0, 1).
     */
    radius: number;
    constructor();
    connectedCallback(): void;
    updated(changedProperties: Map<string | number | symbol, any>): void;
    [$updateProperties](): void;
    get [$effectOptions](): ConstructorParameters<typeof SelectiveBloomEffect>[2];
}

declare global {
    interface HTMLElementTagNameMap {
        'effect-composer': MVEffectComposer;
        'pixelate-effect': MVPixelateEffect;
        'bloom-effect': MVBloomEffect;
        'selective-bloom-effect': MVSelectiveBloomEffect;
        'color-grade-effect': MVColorGradeEffect;
        'outline-effect': MVOutlineEffect;
        'ssao-effect': MVSSAOEffect;
        'smaa-effect': MVSMAAEffect;
        'glitch-effect': MVGlitchEffect;
    }
}

export { MVBloomEffect as BloomEffect, MVColorGradeEffect as ColorGradeEffect, MVEffectBase as EffectBase, MVEffectComposer as EffectComposer, MVGlitchEffect as GlitchEffect, MVOutlineEffect as OutlineEffect, MVPixelateEffect as PixelateEffect, MVSMAAEffect as SMAAEffect, MVSSAOEffect as SSAOEffect, MVSelectiveBloomEffect as SelectiveBloomEffect, SelectiveMixin };
