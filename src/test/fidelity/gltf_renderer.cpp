/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "app/Config.h"
#include "app/FilamentApp.h"
#include "app/MeshAssimp.h"

#include <filament/driver/PixelBufferDescriptor.h>
#include <filament/Engine.h>
#include <filament/LightManager.h>
#include <filament/Material.h>
#include <filament/MaterialInstance.h>
#include <filament/RenderableManager.h>
#include <filament/TransformManager.h>
#include <filament/Scene.h>
#include <filament/Texture.h>
#include <filament/IndirectLight.h>
#include <filament/View.h>

#include <utils/Path.h>
#include <utils/EntityManager.h>

#include <image/ColorTransform.h>
#include <imageio/ImageEncoder.h>

#include <math/mat3.h>
#include <math/mat4.h>
#include <math/vec3.h>

#include <getopt/getopt.h>

#include <stdlib.h>
#include <stb_image.h>

#include <fstream>
#include <memory>
#include <map>
#include <string>
#include <vector>

using namespace filament::math;
using namespace filament;
using namespace filamat;
using namespace utils;
using namespace image;

const int FRAME_TO_SKIP = 10;

static std::vector<Path> g_filenames;

static std::map<std::string, MaterialInstance*> g_materialInstances;
static std::unique_ptr<MeshAssimp> g_meshSet;
static const Material* g_material;
static Entity g_light;

static bool g_rendered = false;
static int g_currentFrame = 0;

static Config g_config;

static void printUsage(char* name) {
    std::string usage(
            "gltf_viewer displays gltf models using the filament renderer\n"
            "Usage:\n"
            "    gltf_viewer [options] <gltf/glb>\n"
            "Options:\n"
            "   --help, -?\n"
            "       Prints this message\n\n"
            "   --width=<width>, -w <width>\n"
            "       Width of the render\n\n"
            "   --height=<height>, -h <height>\n"
            "       Height of the render\n\n"
            "   --output=<path>, -o <path>\n"
            "       Output path where a PNG of the render will be saved\n\n"
            "   --ibl=<path to cmgen IBL>, -i <path>\n"
            "       Applies an IBL generated by cmgen's deploy option\n\n"
    );
    std::cout << usage;
}

static int handleCommandLineArgments(int argc, char* argv[], Config* config) {
    static constexpr const char* OPTSTR = "?i:w:h:o:";
    static const struct option OPTIONS[] = {
            { "help",           no_argument,       nullptr, '?' },
            { "ibl",            required_argument, nullptr, 'i' },
            { "width",          no_argument,       nullptr, 'w' },
            { "height",         no_argument,       nullptr, 'h' },
            { "output",         required_argument, nullptr, 'o' },
            { 0, 0, 0, 0 }  // termination of the option list
    };
    int opt;
    int option_index = 0;
    while ((opt = getopt_long(argc, argv, OPTSTR, OPTIONS, &option_index)) >= 0) {
        std::string arg(optarg ? optarg : "");
        switch (opt) {
            default:
            case '?':
                printUsage(argv[0]);
                exit(0);
            case 'w':
                config->width = std::stoi(arg);
                break;
            case 'h':
                config->height = std::stoi(arg);
                break;
            case 'o':
                config->outputPath = arg;
                break;
            case 'i':
                config->iblDirectory = arg;
                break;
        }
    }

    return optind;
}

template<typename T>
static LinearImage toLinear(size_t w, size_t h, size_t bpr, const uint8_t* src) {
    LinearImage result(w, h, 3);
    math::float3* d = reinterpret_cast<math::float3*>(result.getPixelRef(0, 0));
    for (size_t y = 0; y < h; ++y) {
        T const* p = reinterpret_cast<T const*>(src + y * bpr);
        for (size_t x = 0; x < w; ++x, p += 3) {
            math::float3 sRGB(p[0], p[1], p[2]);
            sRGB /= std::numeric_limits<T>::max();
            *d++ = sRGB;
        }
    }
    return result;
}

static void cleanup(Engine* engine, View* view, Scene* scene) {
    for (auto& item : g_materialInstances) {
        auto materialInstance = item.second;
        engine->destroy(materialInstance);
    }
    g_meshSet.reset(nullptr);
    engine->destroy(g_material);

    EntityManager& em = EntityManager::get();
    engine->destroy(g_light);
    em.destroy(g_light);
}

static void setup(Engine* engine, View* view, Scene* scene) {
    g_meshSet = std::make_unique<MeshAssimp>(*engine);
    for (auto& filename : g_filenames) {
        g_meshSet->addFromFile(filename, g_materialInstances, false);
    }

    auto& rcm = engine->getRenderableManager();
    auto& tcm = engine->getTransformManager();

    // Compute the scale required to fit the model's bounding box into [-1, 1]
    float maxExtent = 0;
    maxExtent = std::max(g_meshSet->maxBound.x - g_meshSet->minBound.x, g_meshSet->maxBound.y - g_meshSet->minBound.y);
    maxExtent = std::max(maxExtent, g_meshSet->maxBound.z - g_meshSet->minBound.z);
    float scaleFactor = 2.325f / maxExtent;

    float3 center = -1 * (g_meshSet->maxBound + g_meshSet->minBound) / 2.0f;
    center.z -= 4.0f / scaleFactor;

    auto rooti = tcm.getInstance(g_meshSet->rootEntity);
    tcm.setTransform(rooti, mat4f::scale(float3(scaleFactor)) * mat4f::translate(center));

    for (auto renderable : g_meshSet->getRenderables()) {
        if (rcm.hasComponent(renderable)) {
            auto instance = rcm.getInstance(renderable);
            rcm.setCastShadows(instance, true);
            rcm.setReceiveShadows(instance, true);
            scene->addEntity(renderable);
        }
    }

    g_light = EntityManager::get().create();
    LightManager::Builder(LightManager::Type::SUN)
            .color(Color::toLinear<ACCURATE>(sRGBColor(1.0f, 1.0f, 1.0f)))
            .intensity(110000)
            .direction({ 0.0, -1, 0.0 })
            .sunAngularRadius(1.9f)
            .build(*engine, g_light);

    scene->addEntity(g_light);
}

static void postRender(Engine*, View* view, Scene*, Renderer* renderer) {
  int frame = g_currentFrame - FRAME_TO_SKIP - 1;
    // Account for the back buffer
  if (frame == 1) {

    std::cout << "Rendering\n";
    const Viewport& vp = view->getViewport();
    uint8_t* pixels = new uint8_t[vp.width * vp.height * 3];

    struct CaptureState {
      View* view = nullptr;
    };

    driver::PixelBufferDescriptor buffer(pixels, vp.width * vp.height * 3,
        driver::PixelBufferDescriptor::PixelDataFormat::RGB,
        driver::PixelBufferDescriptor::PixelDataType::UBYTE,
        [](void* buffer, size_t size, void* user) {
          if (size > 0) {
            CaptureState* state = static_cast<CaptureState*>(user);
            const Viewport& v = state->view->getViewport();

            LinearImage image(toLinear<uint8_t>(v.width, v.height, v.width * 3,
                  static_cast<uint8_t*>(buffer)));

            std::string name = g_config.outputPath;
            Path out(name);

            std::ofstream outputStream(out, std::ios::binary | std::ios::trunc);
            ImageEncoder::encode(outputStream, ImageEncoder::Format::PNG, image, "", name);

            delete[] static_cast<uint8_t*>(buffer);
            delete state;

            g_rendered = true;
          }
        },
        new CaptureState { view });

    renderer->readPixels(
        (uint32_t) vp.left, (uint32_t) vp.bottom, vp.width, vp.height, std::move(buffer));
  }

  if (g_rendered == true) {
    FilamentApp::get().close();
  }

  g_currentFrame++;
}

int main(int argc, char* argv[]) {
    int option_index = handleCommandLineArgments(argc, argv, &g_config);
    int num_args = argc - option_index;
    if (num_args < 1) {
        printUsage(argv[0]);
        return 1;
    }

    for (int i = option_index; i < argc; i++) {
        utils::Path filename = argv[i];
        if (!filename.exists()) {
            std::cerr << "file " << argv[option_index] << " not found!" << std::endl;
            return 1;
        }
        g_filenames.push_back(filename);
    }

    FilamentApp& filamentApp = FilamentApp::get();
    filamentApp.run(g_config, setup, cleanup, nullptr, nullptr, postRender, g_config.width, g_config.height);

    return 0;
}
